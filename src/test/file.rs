use crate::*;


// generated by build script
include!(concat!(env!("OUT_DIR"), "/test.rs"));


pub struct TestExpectations
{
    encoding: Option<util::BitVec>,
    messages: Vec<TestMessageExpectation>,
    command: Option<Vec<String>>,
    output_files: Vec<String>,
}


pub struct TestMessageExpectation
{
    file: String,
    kind: diagn::MessageKind,
    line: usize,
    excerpt: String,
}


pub fn extract_expectations(
    orig_filename: &str,
    contents: &str)
    -> TestExpectations
{
    let mut expectations = TestExpectations {
        encoding: None,
        messages: Vec::new(),
        command: None,
        output_files: Vec::new(),
    };

    let mut line_num = 0;

    for line in contents.lines()
    {
        if let Some(value_index) = line.find("; =")
        {
            let mut encoding = expectations.encoding
                .unwrap_or_else(|| util::BitVec::new());

            let value_str = line.get((value_index + 3)..).unwrap().trim();
            if value_str != "0x"
            {
                let value =
                    syntax::excerpt_as_bigint(
                        None,
                        diagn::Span::new_dummy(),
                        value_str)
                    .unwrap();
                
                let index = encoding.len();
                encoding.write_bigint(index, &value);
            }

            expectations.encoding = Some(encoding);
        }
        else if line.find("; error:").is_some() ||
            line.find("; note:").is_some()
        {
            let messages = line
                .get((line.find("; ").unwrap() + 1)..).unwrap()
                .split("/")
                .map(|s| s.trim());

            for message in messages
            {
                let parts = message.split(":").map(|s| s.trim()).collect::<Vec<&str>>();

                let kind = match parts[0]
                {
                    "error" => diagn::MessageKind::Error,
                    "note" => diagn::MessageKind::Note,
                    _ => unreachable!(),
                };

                let (file, line, excerpt) = if parts.len() > 2
                {
                    let file = if parts[1] == "_"
                    {
                        orig_filename.to_string()
                    }
                    else
                    {
                        parts[1].to_string()
                    };

                    (file, parts[2].parse::<usize>().unwrap() - 1, parts[3].to_string())
                }
                else
                {
                    (orig_filename.to_string(), line_num, parts[1].to_string())
                };

                expectations.messages.push(TestMessageExpectation {
                    kind,
                    file,
                    line,
                    excerpt,
                });
            }
        }
        else if let Some(pos_command) = line.find("; command: ")
        {
            let mut args = line
                .get((pos_command + "; command: ".len())..).unwrap()
                .split(" ")
                .map(|s| s.trim().to_string())
                .collect::<Vec<_>>();

            args = args.into_iter()
                .map(|arg| match arg.as_ref() {
                    "[file]" => orig_filename.to_string(),
                    _ => arg,
                })
                .collect();

            args.insert(0, "customasm".to_string());

            expectations.command = Some(args);
        }
        else if let Some(pos_output) = line.find("; output: ")
        {
            expectations.output_files.push(line
                .get((pos_output + "; output: ".len())..).unwrap()
                .trim()
                .to_string());
        }
        else if line.find(";").is_some() && line.find(":").is_some()
        {
            panic!("unrecognized test expectation");
        }

        line_num += 1;
    }

    expectations
}


fn populate_fileserver(
    fileserver: &mut util::FileServerMock,
    folder: &std::path::Path,
    cur_folder_name: &str)
{
    for entry in std::fs::read_dir(folder).unwrap()
    {
        let entry = entry.unwrap();
        let path = entry.path();
        let file_stem = path.file_name().unwrap().to_string_lossy();

        if path.is_file()
        {
            let mut filename = cur_folder_name.to_string();
            filename.push_str(&file_stem);

            let contents = std::fs::read_to_string(&path).unwrap();
            fileserver.add(&filename, contents);
        }
        else
        {
            let mut new_folder_name = cur_folder_name.to_string();
            new_folder_name.push_str(&file_stem);
            new_folder_name.push_str("/");

            populate_fileserver(fileserver, &path, &new_folder_name);
        }
    }
}


pub fn test_file(filepath: &str)
{
    let path_prefix = std::path::PathBuf::from(&filepath)
        .parent()
        .unwrap()
        .to_path_buf();

	let contents = std::fs::read_to_string(&filepath).unwrap();
	
    let stripped_filename = std::path::PathBuf::from(&filepath)
        .strip_prefix(&path_prefix)
        .unwrap()
        .to_string_lossy()
        .into_owned();

	let expectations = extract_expectations(
        &stripped_filename,
        &contents);

    if expectations.encoding.is_none() &&
        expectations.messages.len() == 0 &&
        expectations.command.is_none() &&
        expectations.output_files.len() == 0
    {
        return;
    }

	let mut fileserver = util::FileServerMock::new();
    populate_fileserver(&mut fileserver, &path_prefix, "");
	fileserver.add_std_files(test::STD_FILES);

	let mut report = diagn::Report::new();


    let maybe_assembly = {
        if let Some(command) = expectations.command
        {
            println!("command: {:?}", command);
            println!("output: {:?}", expectations.output_files);

            driver::drive(
                &mut report,
                &command,
                &mut fileserver)
        }
        else
        {
            let opts = asm::AssemblyOptions {
                debug_iterations: true,
                ..asm::AssemblyOptions::new()
            };

            Ok(asm::assemble(
                &mut report,
                &opts,
                &mut fileserver,
                &[stripped_filename]))
        }
    };


    let mut msgs = Vec::<u8>::new();
    report.print_all(&mut msgs, &fileserver, true);
    print!("{}", String::from_utf8(msgs).unwrap());


    let mut has_msg_mismatch = false;
    for msg in &expectations.messages
    {
        if !report.has_message_at(
            &mut fileserver,
            &msg.file,
            msg.kind,
            msg.line,
            &msg.excerpt)
        {
            println!("\n\
                > test failed -- missing diagnostics message\n\
                > expected: `{}` at file `{}`, line {}\n",
                msg.excerpt, msg.file, msg.line + 1);

            has_msg_mismatch = true;
        }
    }


    let encoding = maybe_assembly
        .map(|asm| asm.output)
        .unwrap_or(None)
        .unwrap_or_else(|| util::BitVec::new());
    
    if has_msg_mismatch
    {
        println!("got encoding: 0x{:x}", &encoding);
        panic!("test failed");
    }

    if expectations.messages.len() != report.len_with_inner()
    {
        println!("\n\
            > test failed -- diagnostics mismatch\n\
            > expected {} messages, got {}\n",
            expectations.messages.len(), report.len_with_inner());
            
        println!("got encoding: 0x{:x}", &encoding);
        panic!("test failed");
    }
    
    if let Some(expected_encoding) = expectations.encoding
    {
        if format!("{:x}", encoding) != format!("{:x}", expected_encoding)
        {
            println!("\n\
                > test failed -- encoding mismatch\n\
                > got:      0x{:x}\n\
                > expected: 0x{:x}\n",
                &encoding, &expected_encoding);
                
            panic!("test failed");
        }
    }

    for filename in &expectations.output_files
    {
        use util::FileServer;

        let handle_expected = fileserver.get_handle_unwrap(
            filename);

        let handle_written = fileserver.get_handle_unwrap(
            &format!(
                "{}{}",
                filename,
                util::FILESERVER_MOCK_WRITE_FILENAME_SUFFIX));

        let mut contents_expected = fileserver.get_bytes_unwrap(
            handle_expected);

        let mut contents_written = fileserver.get_bytes_unwrap(
            handle_written);

        // Normalize line endings if it's a text file
        if filename.ends_with(".txt")
        {
            contents_expected.retain(|c| *c as char != '\r');
            contents_written.retain(|c| *c as char != '\r');
        }

        if contents_expected != contents_written
        {
            println!("\n\
                > test failed -- output file mismatch\n\
                > file: `{}`\n\
                > contents copied to `test_output_mismatch` for debugging\n",
                filename);

            println!("\
                > got:      {:x?}\n\
                > expected: {:x?}\n",
                contents_written,
                contents_expected);

            std::fs::write("test_output_mismatch", contents_written)
                .unwrap();
                
            panic!("test failed");
        }
    }
}